Ada formatting tool.

Copyright 2000, 2002, 2004, 2005, 2006, 2007, 2009, 2011, 2012, 2016, 
          2019, 2021
   AXE Consultants.
P.O. Box 1512, Madison WI  53701
E-Mail: randy@rrsoftware.com

ARM_Form is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License version 3
as published by the Free Software Foundation.

AXE CONSULTANTS MAKES THIS TOOL AND SOURCE CODE AVAILABLE ON AN "AS IS"
BASIS AND MAKES NO WARRANTY, EXPRESS OR IMPLIED, AS TO THE ACCURACY,
CAPABILITY, EFFICIENCY, MERCHANTABILITY, OR FUNCTIONING OF THIS TOOL.
IN NO EVENT WILL AXE CONSULTANTS BE LIABLE FOR ANY GENERAL,
CONSEQUENTIAL, INDIRECT, INCIDENTAL, EXEMPLARY, OR SPECIAL DAMAGES,
EVEN IF AXE CONSULTANTS HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

A copy of the GNU General Public License is available in the file
gpl-3-0.txt in the standard distribution of the ARM_Form tool.
Otherwise, see <http://www.gnu.org/licenses/>.

If the GPLv3 license is not satisfactory for your needs, a commercial
use license is available for this tool. Contact Randy at AXE Consultants
for more information.


The formatting tool is written in Ada 2005, but mainly uses Ada 95 constructs.
Thus, it should be possible to compile it with an Ada 95 compiler with only
small modifications.


Running the formating tool:

The formating tool reads the source text input files (.MSS files) in a
Scribe-like format. The files to read, and general formatting parameters,
are controlled by a master input file (.MSM file). The tool allows determining
the output document, format, and other properties.

The output of the tool is written into a subdirectory
"Output" of the directory where Arm_Form is run. The tool is self-contained; it
does not require any pre or post processing except to have Word create the real
table of contents for the .RTF outout.

Usage: Arm_Form <Master_File> [<Format>[ <Changes>[ <BaseVers> [<ChgVers>[ <Output_Path>]]]]]

The <Master_File> specifies the layout of the document to generate (see below).
If <Master_File> has no extension, ".MSM" is assumed.

The formats are:
   Text: Pure text files. These are missing a lot of formatting; we recommend
	 using the HTML versions instead.
   HTML: (Default) HTML files. The HTML is designed for HTML version 4.0. Old
         browsers may display the documents with little formatting.
   RTF:  RTF files. The RTF files are designed for Word 97 and later. PDF
	 versions should be created from these file using Word and Adobe tools.
   Corr: Text files with !corrigendum like markup.
   Info: File in the open source Info format (not supported by AXE).

<Changes> are:
   No-Changes: The original text (same as specifying version 0).
   New-Only: Text with changes applied through the specified change
             version (<ChgVers>). There are no marking for changes.
   Show-Changes: The text with changes shown and marked for versions
                 <BaseVers> though <ChgVers>. Changes for older versions
                 are applied without marking. For HTML, deleted text is shown
                 as struck-through and inserted text as underlined. Changes for
		 different versions are in different colors.
		 For RTF, this uses Word's "changes" mechanisms, which can
                 shows changes in different colors.
   New-Changes: The text with changes applied for versions <BaseVers> though
                <ChgVers>, with insertions marked. Deletions are marked by just
                a single blank space. (See Show-Changes for how these are
                marked). This form is intended to be used with revision bars
                in Word 97/2000 (Older versions of Word do not reformat the
                document when deletions are hidden, leaving unsightly blank
                spaces. This is not a problem with current versions of Word).

<BaseVers> and <ChgVers> = a value in 0 .. 9 representing the base and
                primary change version desired.

<Output_Path> = the path to which to write the result files. This must end
   with a path separator.

Summary of commands used in the ARM text input files (.MSM and .MSS files):

Syntax summary:

Commands are represented by @<command_name>[<args>]. The command name can be an
identifier, or certain special characters. The command name is not
case-sensitive: @newpage; @NewPage; @NEWPAGE; all represent the same command.
The argument list (if any) is surrounded by one of the bracket pairs
(), {}, [], <>, `', "", or %%. These pairs are equivalent, however the matching
end character must be used to close an argument list. The arguments can be anything.
It can be another sequence of text, keywords, or other items (described below).
In this list below, arguments are always signified by {}, but any of the other
characters can be used. (Note that there is no escape character for the
brackets, so if one of the bracket characters appears in the text, a different
pair of bracket characters should be used. Also note that there is no sane way
to tell the end of a quoted parameter from the end of a nested quoted command,
so parameters nested in a "" pair should never used "" as their brackets. A
similar restriction applies to the %% pair.)

-----------------

Master file (.MSM) command summary:

The master file determines the source files that make up a document and their
collating order, along with general properties of the output as a whole.

Note that regular source commands are not allowed in the master file, unless
otherwise noted.

Source commands (the order of these determines the collating order):
@Source{Name=<File Name>,SectionName=<Name>,SectionNumber=<AlphaNum>,NewSection=[T|F]} -
     Specifies a source file for the document. The <File Name> indicates where
     the source file is found, and may include a path if desired. If <File Name>
     does not include an extension, ".MSS" is assumed. <Name> gives
     a short name for the section; it will be used to name the output files,
     if appropriate for the specified kind of output. <AlphaNum> specifies the
     section number; it is either a number in the range 0 to 20, or a letter
     from A .. Z. If NewSection is true (T), this is the first file for the
     indicated section; otherwise, this is a continuation file for the
     section. (If this setting is wrong, there will be extra or missing headers
     for the section.)
@TOC
     Specifies where the table of contents will appear in the collating order;
     if this is omitted, there will be no table of contents.

Global properties:

@ShowIndexEntries
     If given in the master file, index and glossary entries are visibly
     displayed in the document. If this command is not given, these items are
     not displayed (although they may create links if the
     output format supports links).
@HideIndexEntries
     If given in the master file, or ShowIndexEntries is not given, Index and
     glossary entries are not displayed in the document (although they may
     create links if the output format supports links).
@ShowAnnotations
     If given in the master file, annotations will be included in the output.
     "Annotations" are often described as belonging to the "AARM" below.
     "RMOnly" text is not included in the output. If this command is not given,
     the annotations are not included in any form, and "RMOnly" text is
     included.
@HideAnnotations
     If given in the master file, or ShowAnnotations is not given,
     annotations are not included in the output in any form, and "RMOnly"
     text is included in the output.
@ShowISO
     If given in the master file, text marked "ISOOnly" will be included in the
     output. "NotISO" text is not included in the output. If this command is
     not given, "ISOOnly" text is not included in any form, and "NotISO" text
     is included.
@HideISO
     If given in the master file, or ShowISO is not given,
     "ISOOnly" text is not included in the output in any form, and "NotISO"
     text is included in the output.
@LinkNonTerminals
     If given in the master file, non-terminals are linked to their original
     definition (as given in @Syn and similar commands). Otherwise,
     non-terminals are not linked.
@NumberParagraphs
     If given in the master file, paragraphs are numbered per subclause
     (as in the Ada Reference Manual). Otherwise, paragraphs are not numbered.
@Title{Version=[<version>],Text=[<title_text>]}
     The document title for version, this is used in headers and footers.
     If no title is given for the current version, the title of the previous
     version is used; to use the same title for all versions, give the title
     for Version=[0].
@FilePrefix{<Prefix>}
     This specifies the prefix of the output file(s). All of the output files
     will start with this prefix. Keep this short!
@ExampleFont{Swiss|Fixed|Roman}
     This specifies which font is used to display examples.
     This changes the @Exam{<text>} and @begin{Example} formats.
     By default, the Fixed font is used.
@BodyFont{Swiss|Roman}
     This specifies which font is used to display the body of the document.
     This changes all styles that are not defined to use a specific font.
     By default, the Roman font is used.
@NoteFormat{Ada95|ISO2004}
     This specifies the format of notes sections.
     If Ada95, the word "NOTES" is on a separate line, and each note is
     numbered, with the numbers starting at 1 for each section.
     If ISO2004, each note starts with the word "NOTE", and a number,
     with the numbers starting from 1 for each subclause.
     If there is only one note in a subclause, the number should be omitted.
@ContentsFormat{Ada95|ISO2004}
     This specifies the format of contents sections.
     If Ada95, the title is "Table of Contents".
     If ISO2004, the title is "Contents".
@ListFormat{Ada95|ISO2004}
     This specifies the format of numbered lists ("enumerate").
     If Ada95, they're numbered "1.";
     If ISO2004, they're lettered "a)"; inner lists are numbered "1)".
@SubdivisionNames{Chapter|Section|Clause}
     This specifies the names of subdivisions and the format of section headers.
     Note: In this document, top-level subdivisions are called sections,
     and lower-level subdivisions are called clauses, subclauses,
     and subsubclauses. The names in the final output may be different.
     If Chapter, top-level subdivisions are called "chapters" and this appears
     in the titles. Lower-level subdivisions are called "sections". If Section,
     top-level subdivisions are called "sections" and this appears in the
     titles. Lower-level subdivisions are called "clauses". If Clause,
     top-level subdivisions are called "clauses" and this does not appear in
     the title of top-level subdivisions (Annex still appears). Lower-level
     subdivisions are called "subclauses". If this is not given, "Section"
     is used.

HTML Output properties:

@SingleHTMLOutputFile
     If given in the master file, generate a single large file for
     the output, rather than one file per clause. If this is not given,
     smaller files are generated.
@UseMSDOSFilenames
     If given in the master file, use 8.3 MS-DOS style filenames.
     In this case, the @FilePrefix must be less than 4 characters in size,
     and no clause or subclause number should exceed 35
     if @SingleHTMLOutputFile isn't given.
@HTMLKind{Version=[3|4Comp|4],Unicode=[T|F]}
     Specifies the kind of HTML that will be output.
     If Version=3, HTML compatible with (virtually) all browsers will be
     generated, but it will have limited formatting. The Unicode setting is
     ignored; special characters will be output using ASCII equivalents,
     and explicit output with the @Unicode command is prohibited and will
     cause an error.
     If Version=4Comp, the HTML will have more extensive formatting, but older
     browsers will have more limited formatting. If Unicode is true (T),
     Unicode characters will be used where appropriate (presuming the
     characters are available on the US version of Windows 2000); otherwise
     ASCII equivalents will be used. In either case, explicit Unicode
     characters (@Unicode) are generated.
     If Version=4, the HTML will have the best formatting on modern
     browsers (IE 5.0, Firefox 1.0, Netscape 6.2, and later versions of these)
     but older browsers will have almost no formatting. If Unicode is true (T),
     Unicode characters will be used where appropriate (presuming the
     characters are available on the US version of Windows 2000); otherwise
     ASCII equivalents will be used. In either case, explicit Unicode
     characters (@Unicode) are generated.
     The default is a version of 4Comp with Unicode = T.
@HTMLTabs{[SingleSpace|QuadSpace|EmulateFixedOnly|EmulateFixedOnlyQuad|EmulateAll]}
     Specifies how tabs are emulated for text.
     (HTML does not have tabs, they have to be faked.)
     For SingleSpace, the tabs are replaced by a single space (always).
     For QuadSpace, the tabs are replaced by a four hard spaces (always).
     For EmulateFixedOnly, the tabs are replaced by an appropriate number of
     hard spaces for styles using fixed fonts (or if the tab is the first
     character on a line); for other styles, a single space is used.
     For EmulateFixedOnlyQuad, the tabs are replaced by an appropriate number
     of hard spaces for styles using fixed fonts; for other styles, four hard
     spaces are used.
     For EmulateAll, the tabs are replaced by an appropriate number of
     hard spaces for all styles. Note that the number of spaces is a guess
     for non-fixed fonts, and it is unlikely that the tabbed text will line up
     perfectly.
     EmulateFixedOnly is the default (as the result will look correct in a
     fixed font).
@HTMLNavBar{RefName=[<URL>],SrchName=[<URL>],IndexName=[<URL>],
   UseButtons=[T|F],OnTop=[T|F],OnBottom=[T|F]}
     Specifies the properties of the Navigation Bar in the files.
     RefName gives the URL of the references page. This can be part of the
     current document (in which case the URL can be relative), or an external
     page. It will be the URL assigned to the "References" button/label; if set
     to null, the "References" button/label will link to the section named
     "References" if one exists, or the button/label will be omitted otherwise.
     SrchName gives the URL of the search page. This can be a relative or
     absolute URL. It will be the URL assigned to the "Search" button/label; if
     set to null, the "Search" button/label will link to the section named
     "Search" if one exists, or the button/label will be omitted otherwise.
     IndexName gives the URL of the search page. This can be a relative or
     absolute URL. It will be the URL assigned to the "Index" button/label;
     if set to null, the "Index" button/label will link to the section named
     "Index" if one exists, or the button/label will be omitted otherwise.
     If UseButtons is true (T), the navigation bar will use graphic buttons;
     otherwise, text labels will be generated.
     If OnTop is true (T), the navigation bar will be on the top of the
     document page(s) in the header; otherwise it will not appear on top.
     If OnBottom is true (T), the navigation bar will be on the bottom of the
     document page(s) in the footer; otherwise it will not appear on the bottom.
     One of OnTop or OnBottom should be true, or navigation will be difficult!
     By default, the "References" and "Search" buttons are omitted, buttons
     are used, and navigation bars are shown on the top and bottom of every
     page.
@HTMLScript{<Script>}
     Specifies Script code (including the <SCRIPT> </SCRIPT> tags) that should
     go directly before the </HEAD> on each page. By default, this is empty.
     This command was designed to allow placing Google Analytics code on
     each page for web sites that use that for tracking.
@HTMLHeader{<HTML_for_Header>}
     Specifies HTML markup for the header of the the document. This will be
     repeated on every page, and needs to be a self-contained HTML fragment.
     By default, this is empty.
@HTMLFooter{<HTML_for_Footer>}
     Specifies HTML markup for the footer of the the document. This will be
     repeated on every page, and needs to be a self-contained HTML fragment.
     By default, this is empty.
@HTMLColor{Text=[<Color]>,Background=[<Color>],Link=[<Color>],VLink=[<Color>],
   ALink=[<Color>]}
     Specifies the default text, background and link colors for the document.
     <Color> is a color in standard HTML format ("#rrggbb", with each letter
     replaced by a hex digit).
     VLink is the color for visited links; ALink is the color for links
     being clicked. The default is:
     @HTMLColor{Text=[#000000],Background=[#FFFFF0],Link=[#0000FF],
       VLink=[#800080],ALink=[#FF0000]}
     That is, black text, cream background, blue links, purple visited links,
     and red active links.


RTF Output properties:

@SingleRTFOutputFile
     If given in the master file, generate a single large file for
     the output, rather than one file per section. If this is not given,
     smaller files are generated.
@RTFHeaderPrefix{Version=[<version>],Text=[<title_text>]}
     The text given in the header before the title; this is *RTF* text; no
     embedded commands can be given here. If no header prefix is given for the
     current version, the prefix of the previous version is used; to use the
     same prefix for all versions, give the prefix for Version=[0]. If this is
     empty, only the title will be used.
@RTFFooterText{Version=[<version>],Text=[<title_text>]}
     The fixed text given in the footer; this is *RTF* text; no embedded
     commands can be given here. If no footer text is given for the current
     version, the text of the previous version is used; to use the same text for
     all versions, give the prefix for Version=[0]. This text will not be used
     if UseClauseName is True.
@RTFFooter{UseDate=[T|F],UseClauseName=[T|F],UseISOFormat=[T|F]}
     Specifies the format of the footer. The date will be included if
     UseDate is true (T), otherwise it will be omitted; by default it is
     included. The footer text will be the name of the clause that starts the
     page (other clauses may start on the page) if UseClauseName is true (T),
     otherwise it will be the FooterText. The defailt is to use clause names.
     The text font and size will match the ISO requirements if UseISOFormat
     is true (T) - this means the footer will be in a Swiss font with multiple
     sizes; otherwise (and this is the default) the footer will be in the body
     font with a single size.
@RTFPageSize{Letter|A4|HalfLetter|Ada95}
     Specifies the size of the RTF output; Letter is used if this is not
     specified. Letter is 8.5"x11"; A4 is European standard size; HalfLetter
     is 5.5"x8.5"; Ada95 is 7"x9".
@RTFFonts{Serif=[Times|Souvenir],SansSerif=[Arial|Helvetica]}
     Specifies the specific fonts used for the Serif and Sans Serif fonts.
     If not specified, Times ("Times New Roman") and Arial are used.
@RTFVersionName{Version=[<version>],Text=[<title_text>]}
     The specified text names the version as the "author" of any revisions.
     For instance, for the Ada Standard, @RTFVersionName{Version=[2],Text=[Amendment 1]}
     gives the author name "Amendment 1" to all version 2 revisions.

Other commands:

@comment{<text>} - The text is a comment to the master file, and is ignored
	     on output.



---------------------

Source file (.MSS) command summary:

Meta-commands:

@; - Signifies nothing. Used to break a parameterless command from following
     text: "@LegalityName@;s" (otherwise the command "LegalityNames" would be
     looked for).
@: - After a period, signifies an sentence ending period, rather than a
     initial period. Not used currently, but remains in text in case someone
     cares eventually. (Only matters if the amount of space after sentences
     is different than the amount between words within a sentence.)
@| - Marks a potential line break point, without inserting a hyphen. (Scribe
     says that it is a "zero-length word".) Not used currently, as the RTF
     command (\zwbo) prints a square box in both Word 97 and Word 2000 -- and
     no break. Similarly, zero-width space in HTML 4.0 doesn't work on Internet
     Exploder 4.1 - it also prints a square box and no break.
@! - Marks a potential line break point, inserting a hyphen if the break is
     used. (A so-called "soft-hyphen"). Unlike the above, this actually
     works in Word 97 and HTML. &shy.


Text commands:

@@ - the literal character '@'.
@\ - A tab, or end of centered text. Also used to mark the separation between
     hanging text and the rest of the paragraph.
@^ - Sets a tab stop at the current text location. (*Can't implement in RTF and
     HTML does not have tabs at all; has been removed from the text *)
@  - [@<space>] - A hard space; cannot be used to insert a line break.
@* - Line break inside a paragraph.

@+{<text>} - Superscript text (text size will be smaller).
@-{<text>} - Subscript text (text size will be smaller).
@b{<text>} - Bold text.
@i{<text>} - Italic text.
@r{<text>} - Roman font text.
@ri{<text>} -Roman italic text (use for comments in examples).
@s{<text>} - Swiss font text.
@f{<text>} - Fixed-width font text.
@shrink{<text>} - Text is one size smaller. (Typically 1 point smaller).
@grow{<text>} - Text is one size larger. (Typically 1 point larger).
@black{<text>} - Text is in a black color.
@red{<text>} - Text is in a red color.
@green{<text>} - Text is in a green color.
@blue{<text>} - Text is in a blue color.
@comment{<text>} - The text is a comment to the input files, and is ignored
	     on output.
@newpage   - Insert a page break. Ends a paragraph.
@rmnewpage - Insert a page break in the RM (that is, when HideAnnotations is
	     used), ignored otherwise. Ends a paragraph. Use to insert page
	     breaks to make the printed RM look better.
@newcolumn - Insert a column break. Only allowed in a multi-column formats.
	     Ends a paragraph.
@newpagever{Version=[<version>} - Insert a page break if we are generating
             <version> (and ends a paragraph). Otherwise, does nothing.
@rmnewpagever{Version=[<version>} - Insert a page break in the RM (that is,
             when HideAnnotations is used) and we are generating <version>,
	     ignored otherwise. Ends a paragraph. Use to insert page
	     breaks to make the printed RM look better.
@isoonlyrmnewpagever{Version=[<version>} - Insert a page break in the RM (that
	     is, when HideAnnotations is used), @ShowISO was given in
             the master file, and we are generating <version>,
	     ignored otherwise. Ends a paragraph. Use to insert page
	     breaks to make the printed RM look better.
@notisormnewpagever{Version=[<version>} - Insert a page break in the RM (that
	     is, when HideAnnotations is used), @ShowISO was not given in
             the master file, and we are generating <version>,
	     ignored otherwise. Ends a paragraph. Use to insert page
	     breaks to make the printed RM look better.
@newcolumnver{Version=[<version>} -  - Insert a column break if we are generating
             <version>, otherwise does nothing. Only allowed in a multi-column
	     formats. Ends a paragraph.
@softpage  - Insert a soft page break in a format that does not generally
	     allow one. A page is allowed (but not required) at this point.
             [Note: This doesn't seem to work in Word 97, but we've kept it
	     anyway.]
@noprefix  - The following paragraph does not have a prefix (that is, hanging
	     text, numbers, or bullets). For example, if the paragraph is in
	     a bulleted list, it will not have a bullet. This command must be
	     given before any text for the paragraph (including index entries
	     and even spaces in example formats).
@keepnext  - Keep this paragraph with the next one (usually used on leadins,
	     like "The following example shows...:"). This command must be
	     given before any text for the paragraph.
@leading   - This paragraph leads in an example or list. Cut the space
	     following the paragraph (usually by 30%). This command must be
	     given before any text for the paragraph.
@trailing  - This paragraph ends an item of some sort. Increase the space
	     following the paragraph (usually by 50%). This command must be
	     given before any text for the paragraph.
@noparanum - This paragraph has no number. This command must be
	     given before any text for the paragraph.

@thinline  - Draw a thin separator line across the page. Ends any paragraph.
@thickline - Draw a thick separator line across the page. Ends any paragraph.

-- Section/Clause commands:
@LabeledSection{<text>} - Start a labeled section (chapter). The title will be
	"text". The formatter assigns section numbers.
@LabeledSectionNoBreak{<text>} - Start a labeled section (chapter). The
	title will be "text". The formatter assigns section numbers. No page
	break before it.
@LabeledAnnex{<text>} - Start a labeled (unqualified) annex. The title
	will be "text". The formatter assigns annex letters.
@LabeledInformativeAnnex{<text>} - Start a labeled informative annex. The title
	will be "text". The formatter assigns annex letters.
@LabeledNormativeAnnex{<text>} - Start a labeled normative annex. The title
	will be "text". The formatter assigns annex letters.
@LabeledClause{<text>} - Start a labeled clause. The title will be "text".
	The formatter assigns clause numbers.
@LabeledSubClause{<text>} - Start a labeled subclause. The title will be "text".
	The formatter assigns subclause numbers.
@LabeledSubSubClause{<text>} - Start a labeled subsubclause. The title will be "text".
	The formatter assigns subsubclause numbers.
@LabeledRevisedAnnex{Version=[<version>],
    [InitialVersion=[<version>],]New=[<new_text>],Old=[<old_text>]} -
	Start a labeled (unqualified) annex. The title will be "new_text". If
        we are generating an old version of the document, the title is "old_text"
        instead. (Note that annex references in commands always use the
        new_text name.) The formatter assigns annex letters. Version is the
        version number of the change (see @ChgRef for details); InitialVersion
        is the original insertion version of the Old text (this defaults to 0
        if not given).
@LabeledRevisedNormativeAnnex{Version=[<version>],
    [InitialVersion=[<version>],]New=[<new_text>],Old=[<old_text>]} -
	Start a labeled normative annex. The title will be "new_text". If we
        are generating an old version of the document, the title is "old_text"
        instead. (Note that annex references in commands always use the
        new_text name.) The formatter assigns annex letters. Version is the
        version number of the change (see @ChgRef for details); InitialVersion
        is the original insertion version of the Old text (this defaults to 0
        if not given).
@LabeledRevisedInformativeAnnex{Version=[<version>],
    [InitialVersion=[<version>],]New=[<new_text>],Old=[<old_text>]} -
	Start a labeled informative annex. The title will be "new_text". If we
        are generating an old version of the document, the title is "old_text"
        instead. (Note that annex references in commands always use the
        new_text name.) The formatter assigns annex letters. Version is the
        version number of the change (see @ChgRef for details); InitialVersion
        is the original insertion version of the Old text (this defaults to 0
        if not given).
@LabeledRevisedSection{Version=[<version>],
    [InitialVersion=[<version>],]New=[<new_text>],Old=[<old_text>]} -
        Start a labeled section (chapter). The title will be "new_text". If we are
        generating an old version of the document, the title is "old_text" instead.
        (Note that clause references in commands always use the new_text name.)
        The formatter assigns clause numbers. Version is the
        version number of the change (see @ChgRef for details); InitialVersion
        is the original insertion version of the Old text (this defaults to 0
        if not given).
@LabeledRevisedClause{Version=[<version>],
    [InitialVersion=[<version>],]New=[<new_text>],Old=[<old_text>]} -
        Start a labeled clause. The title will be "new_text". If we are
        generating an old version of the document, the title is "old_text" instead.
        (Note that clause references in commands always use the new_text name.)
        The formatter assigns clause numbers. Version is the
        version number of the change (see @ChgRef for details); InitialVersion
        is the original insertion version of the Old text (this defaults to 0
        if not given).
@LabeledRevisedSubClause{Version=[<version>],
    [InitialVersion=[<version>],]New=[<new_text>],Old=[<old_text>]} -
        Start a labeled subclause. The title will be "new_text". If we are
	generating an old version of the document, the title is "old_text" instead.
	(Note that clause references in commands always use the new_text name.)
        The formatter assigns subclause numbers. Version is the
        version number of the change (see @ChgRef for details); InitialVersion
        is the original insertion version of the Old text (this defaults to 0
        if not given).
@LabeledRevisedSubSubClause{Version=[<version>],
    [InitialVersion=[<version>],]New=[<new_text>],Old=[<old_text>]} -
        Start a labeled subsubclause. The title will be "new_text". If we are
	generating an old version of the document, the title is "old_text" instead.
	(Note that clause references in commands always use the new_text name.)
        The formatter assigns subsubclause numbers. Version is the
        version number of the change (see @ChgRef for details); InitialVersion
        is the original insertion version of the Old text (this defaults to 0
        if not given).
@LabeledAddedSection{Version=[<version>],Name=[<new_text>]} - Start a labeled
        section (chapter). The title will be "new_text". If we are generating an old
	version of the document, this clause does not exist. (Any clause references
	ought to be in new text.) The formatter assigns clause numbers. Version
	is the version number of the change (see @ChgRef for details).
@LabeledAddedClause{Version=[<version>],Name=[<new_text>]} - Start a labeled
        clause. The title will be "new_text". If we are generating an old
	version of the document, this clause does not exist. (Any clause references
	ought to be in new text.) The formatter assigns clause numbers. Version
	is the version number of the change (see @ChgRef for details).
@LabeledAddedSubClause{Version=[<version>],Name=[<new_text>]} - Start a labeled
        subclause. The title will be "new_text". If we are generating an old
	version of the document, this subclause does not exist. (Any subclause
	references ought to be in new text.) The formatter assigns subclause
        numbers. Version is the version number of the change (see @ChgRef for
        details).
@LabeledAddedSubSubClause{Version=[<version>],Name=[<new_text>]} - Start a labeled
        subsubclause. The title will be "new_text". If we are generating an old
	version of the document, this subsubclause does not exist. (Any subsubclause
	references ought to be in new text.) The formatter assigns subsubclause
        numbers. Version is the version number of the change (see @ChgRef for
        details).
@LabeledAddedAnnex{Version=[<version>],Name=[<new_text>]]} -
	Start a labeled (unqualified) annex. The title will be "new_text". If we
        are generating an old version of the document, this annex does not appear.
        (Any annex references in commands ought to be "new text".) The
        formatter assigns annex letters. Version is the
        version number of the change (see @ChgRef for details).
@LabeledAddedNormativeAnnex{Version=[<version>],Name=[<new_text>]]} -
	Start a labeled normative annex. The title will be "new_text". If we
        are generating an old version of the document, this annex does not appear.
        (Any annex references in commands ought to be "new text".) The
        formatter assigns annex letters. Version is the
        version number of the change (see @ChgRef for details).
@LabeledAddedInformativeAnnex{Version=[<version>],Name=[<new_text>]} -
	Start a labeled informative annex. The title will be "new_text". If we
        are generating an old version of the document, this annex does not appear.
        (Any annex references in commands ought to be "new text".) The
        formatter assigns annex letters. Version is the
        version number of the change (see @ChgRef for details).
@LabeledDeletedClause{Version=[<version>],Name=[<old_text>]} - Start a labeled
        clause. The title will be "old_text". If we are generating a new
	version of the document, this clause does not exist. (Any clause references
	ought to be in old deleted text.) The formatter assigns clause numbers. Version
	is the version number of the change (see @ChgRef for details).
	[Note: We do not support deleting sections or annexes.]
@LabeledDeletedSubClause{Version=[<version>],Name=[<old_text>]} - Start a labeled
        subclause. The title will be "old_text". If we are generating a new
	version of the document, this subclause does not exist. (Any subclause
	references ought to be in old deleted text.) The formatter assigns subclause
        numbers. Version is the version number of the change (see @ChgRef for
        details).
@LabeledDeletedSubSubClause{Version=[<version>],Name=[<old_text>]} - Start a labeled
        subsubclause. The title will be "old_text". If we are generating a new
	version of the document, this subsubclause does not exist. (Any subsubclause
	references ought to be in old deleted text.) The formatter assigns subsubclause
        numbers. Version is the version number of the change (see @ChgRef for
        details).

@UnnumberedSection{<text>} - Start an unnumbered section. (These are the
	Forward and Introduction). This *can* be referenced by a reference,
	and will appear in the table of contents.
@Subheading{<text>} - Start an unnumbered subclause (a subclause of an
	unnumbered section). These are formatting only, they cannot be
	referenced, nor do they appear in the table of contents.
@Heading{<text>} - Start an unnumbered clause (a clause of an unnumbered
	section). These are formatting only, they cannot be referenced, nor do
	they appear in the table of contents.
@Center{<text>} - Center the otherwise normal text. Note that this is a
	paragraph style and is treated like a header.
@Right{<text>} - Right justify the otherwise normal text. Note that this is a
	paragraph style and is treated like a header.

@PrefaceClause{} - Start a new clause without numbering or title - just a
	page break to an odd page.

@RefSec{<title>} - Generates a reference to the clause "title". (This must
	match exactly except for case). The reference is of the form
	"<clause number>, ``<title>''". (The ARG has directed that this be
	changed to '<clause number>, "<title>"').
@RefSecNum{<title>} - Generates a reference to the clause "title". (This must
	match exactly except for case). The reference is of the form
	"<clause number>".
@RefSecbyNum{<num>} - Generates a reference to the clause with <num> as a
	clause number. This is intended to be used internally to the tool,
	not in document source (the tool assigns the clause numbers).

@LocalTarget{Target=[<target-text>],Text=[<text>]} - Generates a target for
	future @LocalLink commands at the current location. <target-text>
        should be short, using alphanumeric characters. <text> will be
	generated normally, using the current formatting (no formatting
	is allowed in <text>).
@LocalLink{Target=[<target-text>],Sec=[<title>],Text=[<text>]} - Generates a
	link to the target specifed in the section given by "title" (this
	should have been defined by a @LocalTarget command). <text> will be
	generated as the body of the link, using the current formatting (no
	formatting in <text>).
@URLLink{URL=[<URL>],Text=[<text>]} - Generates a link to the URL specified;
	<text> will be the body of the link, using the current formatting (no
	formatting in <text>). The URL should be a complete URL, including
	"http://".
@AILink{AI=[<AI>],Text=[<text>]} - Generates a link to the AI specified;
	<text> will be the body of the link, using the current formatting (no
	formatting in <text>). The AI should be an AI number in the full
	format (AI95-0yyyy-zz, AI05-yyyy-z, or SI99-yyyy-z).

-- Ada specific commands:
@nt{<text>} - A non-terminal in normal text. This will be set in a Swiss
	      (sans-serif) font. Also, for HTML, this will linked to the
              definition text; use @ntf instead if this is not a real
              non-terminal.
@ntf{<text>} - Format as a non-terminal in normal text. This will be set
              in a Swiss (sans-serif) font.
@key{<text>} - A keyword in normal text. This will be set in boldface.
@exam{<text>} - Example text occurring in normal text. This will be set
        in the example font (which is selected in the master file).
@examcom{<text>} - The body of an example comment; this is shown in the
        roman font in italics. (This is the same as the @RI command, but
        by using a separate name, we can change the format in the future.)
@redundant{<text>} - Marks text thought to be unnecessary in the RM. That is,
	the rules are explained elsewhere. The text is formatted normally.
	When annotations are shown, this text is surrounded in brackets.
        When annotations are not shown, no special formatting is used.

@syn{[Tabs=<Tabset>, ]LHS=<Non-terminal>, RHS=<Production>}
       - Marks a syntax production.
	<Production> contains @syn2 (and @synf) commands for RHS non-terminals.
	<Tabset> defines any tabs needed by the <Production>.
	The <Non-terminal> is indexed. The <Non-Terminal> and <Production>
	(and the clause number) are sent to the syntax manager. Also, saves
	<Non-terminal> for any following @Syn2 to use. The command also writes
	    @nt<Non-Terminal> ::= <Production>
	to the output.
	Note: <Non-Terminal> and <Production> allow @Chg commands.
@syni{<prefix>} - Generates <prefix> in the italics of a non-terminal prefix.
@syn2{<name>} - Marks a non-terminal name in the production of a syntax rule.
	If the current non-terminal is not null, generates a cross reference
	entry: <Name> in <Non-Terminal> at <ClauseNum>. Also, generate an index
	entry for the item: @Defn2(Term=<Name>,Sec=@i{used}). (For the purposes
	of the index, all of Annex P is a single paragraph). Otherwise, is the
	same as @nt.
@synf{<name>} - Marks a non-terminal name in the production of a syntax rule,
	for which there is no formal definition in the document. (Character
	set names in Ada fall into this category).
	If the current non-terminal is not null, generates a cross reference
	entry: <Name> in <Non-Terminal> at <ClauseNum>. Also, generate an index
	entry for the item: @Defn2(Term=<Name>,Sec=@i{used}). (For the purposes
	of the index, all of Annex P is a single paragraph). Otherwise, is the
	same as @ntf.
@syntaxsummary -- Generate the syntax summary at this point. *No paragraph
	numbers*!
@syntaxxref -- Generate the syntax cross-reference at this point. *No paragraph
	numbers*!
@AddedSyn{Version=[<Version>],[Tabs=<Tabset>, ]LHS=<Non-terminal>, RHS=<Production>}
	Add a syntax production for Version. Otherwise, the meaning is the
	same as for @Syn, above. Note: <Non-terminal> and <Production> need
	@Chg commands; this command only adds processing for "::=" and overall
	inclusion or skipping when necessary.
@DeletedSyn{Version=[<Version>],[Tabs=<Tabset>, ]LHS=<Non-terminal>, RHS=<Production>}
	Delete a syntax production for version. Otherwise, the meaning is the
	same as for @Syn, above. Note: <Non-terminal> and <Production> need
	@Chg commands; this command only adds processing for "::=" and overall
	inclusion or skipping when necessary.

@Attribute{Prefix=<Prefix>,AttrName=<Name>,Text=<Text>}
	Defines an attribute. Creates a hanging text item <Prefix>'<Name>,
	with the specified text. The text can contain arbitrary commands;
	it will be run through the full evaluation code.
	The attribute and text is also sent to a database used to later create
	Annex K. (This uses the current value of PrefixType.) Finally, the
	attribute <Name> is indexed as by calling @Defn2{Term=[Attribute],
	Sec=<Name>}, and as by calling @Defn{<Name> attribute}. See also
	ChgAttribute.
@AttributeLeading{Prefix=<Prefix>,AttrName=<Name>,Text=<Text>}
        Same as attribute, except that the first paragraph is a "Leading"
	paragraph. (Use when the second paragraph is a DescExample, such
	as when a function specification is given.)
@AttributeList
	Dumps the summary list of all attributes from the attribute database
	to the output file.
@PrefixType{text}
	Save the indicated text to use as part of any following attribute
	definitions. The text is also written to the output. The text should
	fit in the phrase: "For {text}:". For instance, the text could be
	"every scalar subtype S". See also ChgPrefixType.
@EndPrefixType{}
	(The parameter list must exist and be empty) Set the saved attribute
	text to "@b{NONE!}". This exists to ensure that the prefixes are set
	properly, and aren't just set by accident.

@PragmaSyn{<Text>}
	Defines a pragma. The text is displayed in the current format.
	The text should contain an @prag command (which specifies and indexes
	the name - see below.) The text can contain arbitrary commands;
	it will be run through the full evaluation code.
	The text is also sent to a database used to later create Annex L.
@AddedPragmaSyn{Version=[<Version>],<Text>}
	Defines a pragma added by <Version>. Otherwise, the text is as
        described for PragmaSyntax. Text includes an appropriate @Chg;
        the purpose of the Version number here is
	to determine whether (and how) this is entered into Annex L,
	along with the cross-reference text.
@DeletedPragmaSyn{Version=[<Version>],InitialVersion=[<InitialVersion>],<Text>}
	Defines a pragma deleted by <Version>, originally added by
        <InitialVersion>. Otherwise, the text is as
        described for PragmaSyntax. Text includes an appropriate @Chg;
	the purpose of the Version number here is to determine whether
        (and how) this is entered into Annex L, along with the cross-reference
        text.
@PragmaList
	Dumps the summary list of all pragmas from the pragma database
	to the output file.

-- Indexing:

If Show-Index-Entries is not used on the command line, indexing entries
are transparent (this is usually the case for the RM).

If Show-Index-Entries is used on the command line, indexing entries show as
italized in curly brackets. RootDefn adds "[distributed]", PDefn adds
"[partial]", IndexSee adds ": see <OtherTerm>", and IndexSeeAlso adds
": see also <OtherTerm>" to the reference.

@IndexList - Generates the index at this point.

@defn{<text>} - Defines a term, where the entire definition is given in the
	referenced paragraph.
@rootdefn{<text>} - Defines a term, where the definition is given in several
	paragraphs. This is the primary definition.
@pdefn{<text>} - Defines a term, where the definition is given in several
	paragraphs. This is one of the secondary definitions.
@defn2{Term=[<term>],Sec=(<subterm>)} - Same as Defn, except a subterm is
	allowed. The subterm will be indexed under the primary term.
@rootdefn2{Term=[<term>],Sec=(<subterm>)} - Same as RootDefn, except a
	subterm is allowed.
@pdefn2{Term=[<term>],Sec=(<subterm>)} - Same as PDefn, except a subterm is
	allowed.
@seeother{Primary=[<term>],Other=(<other_term>)} - Generates a See
	reference to <other_term> in the index. No page/clause reference is
	generated.
@seealso{Primary=[<term>],Other=(<other_term>)} - Generates a See also
	reference to <other_term> in the index. No page/clause reference is
	generated.
@indexsee{Term=[<term>],See=(<other_term>)} - Generates a See
	reference to <other_term> in the index. A page/clause reference is
	generated.
@indexseealso{Term=[<term>],See=(<other_term>)} - Generates a See also
	reference to <other_term> in the index. A page/clause reference is
	generated.
@ChildUnit{Parent=[<parent>],Child=[<child>]}
	Generates three index entries: An index entry for <child>, with a secondary
	of "@i{child of} <parent>", an index entry for "Language-Defined
	Library Units" with a secondary entry of <parent>.<child>, and an index
	entry for <parent>.<child>. The Unit is set to <parent>.<child>.
        (For version 2 or later, the Language-Defined entry is not generated.)
        The first entry is added to the package list as well.
@SubChildUnit{Parent=[<parent>],Child=[<child>]}
        Same as @ChildUnit, except that the first entry is added to the
	subprogram list, rather than the package list.
@RootLibUnit{<unit>} - Generates two index entries: An index entry for
	"Language-Defined Library Units" with a secondary entry of <unit>,
	and an index entry for <unit>. The Unit is set to <parent>.<child>.
        (For version 2 or later, the Language-Defined entry is not generated.)
        The first entry is added to the package list as well.
@AdaDefn{<defn>} - Generates an index entry for <defn> with a secondary entry
	of "@i{in} <Unit>" (where Unit is the unit saved by a previous
	RootLibUnit or ChildUnit.) Also outputs the <defn> to the output file.
@AdaSubDefn{<defn>} - Generates two index entries: one for <defn> with a
	secondary entry of "@i{in} <Unit>" (where Unit is the unit saved by
	a previous RootLibUnit or ChildUnit.), and second for "Language-Defined
	Subprogram" with a secondary entry of "<defn> @i{in} <Unit>".
        (For version 2 or later, the Language-Defined entry is not generated.)
        The first entry is added to the subprogram list as well.
	Also outputs the <defn> to the output file.
@AdaTypeDefn{<defn>} - Generates two index entries: one for <defn> with a
	secondary entry of "@i{in} <Unit>" (where Unit is the unit saved by
	a previous RootLibUnit or ChildUnit.), and second for "Language-Defined
	Type" with a secondary entry of "<defn> @i{in} <Unit>".
        (For version 2 or later, the Language-Defined entry is not generated.)
        The first entry is added to the type list as well.
	Also outputs the <defn> to the output file.
@AdaSubTypeDefn{Name=<defn>,Of=<type>} - Generates an index entry of
        "<defn> @i{subtype of} <type>" with a secondary entry of
        "@i{in} <Unit>" (where Unit is the unit saved by a previous
        RootLibUnit or ChildUnit.) The entry is added to the type list as well.
	Also outputs the <defn> to the output file.
@AdaExcDefn{<defn>} - Generates an index entry for <defn> with a
	secondary entry of "@i{in} <Unit>" (where Unit is the unit saved by
	a previous RootLibUnit or ChildUnit.)
        The entry is added to the exception list as well.
	Also outputs the <defn> to the output file.
@AdaObjDefn{<defn>} - Generates an index entry for <defn> with a
	secondary entry of "@i{in} <Unit>" (where Unit is the unit saved by
	a previous RootLibUnit or ChildUnit.)
        The entry is added to the object list as well.
	Also outputs the <defn> to the output file.
@AdaPackDefn{<defn>} - Generates an index entry for <defn> with a
	secondary entry of "@i{in} <Unit>" (where Unit is the unit saved by
	a previous RootLibUnit or ChildUnit.)
        The entry is added to the package list as well.
	Also outputs the <defn> to the output file.
	Use this for *nested* packages.
@IndexCheck{<check>} - Generates an index entry for "check, language defined"
	with a secondary entry of <check>. (Essentially a Defn2). Also,
	indexes <check> as a partial definition. (PDefn).
@Attr{<name>} -- Generates an index entry for "attributes"
	with a secondary entry of <name>. (Essentially a Defn2). Also
	with a secondary entry of <name> (a Defn2), and also an index entry
        of "<name> attribute" (a Defn). Also puts <name> to the output.
@Prag{<name>} -- Generates an index entry for "pragmas"
	with a secondary entry of <name> (a Defn2), and also an index entry
        of "<name> pragma" (a Defn). Also puts <name> to the output.
@AspectDefn{<name>} -- Generates an index entry for "aspects"
	with a secondary entry of <name> (a Defn2), and also an index entry
        of "<name> aspect" (a Defn).


@PackageList -- Generates the list of language-defined packages.
@TypeList -- Generates the list of language-defined types and subtypes.
@SubprogramList -- Generates the list of language-defined subprograms.
@ExceptionList -- Generates the list of language-defined exceptions.
@ObjectList -- Generates the list of language-defined objects.

-- Glossary:
@ToGlossary(Term=[<term>], Text=[<text>])
	Creates a glossary entry for <term> with the value <text>.
	The item is shown as a annotation in the AARM. The term is also
	indexed (and displayed as such if appropriate) with @Defn immediately
	after the annotation header.
@ToGlossaryAlso(Term=[<term>], Text=[<text>])
	Creates a glossary entry for <term> with the value <text>.
	The text is part of the current paragraph. If Show-Index-Entries is
	used on the command line, a "[Glossary Entry]" marker is shown;
	otherwise nothing is. The term is also indexed (and displayed as
	such if appropriate) with @Defn immediately after the marker.
@GlossaryList
	Generates the glossary.

-- Implementation-defined annex:
@ImplDef{<text>}
	Creates an implementation-defined entry for <text>. The clause and
	paragraph references are saved to create part of Annex M. For the AARM,
	<text> is an annotation; otherwise, it is discarded. See also
	ChgImplDef.
@ImplDefList
	Generates the implementation-defined list.

-- Changes:
@chgref{Version=[<version>],Kind=(<kind>){,Ref=(<DR_Number>)}{,ARef=(<AI_Number>)}}
	- Marks a paragraph changed in a corrigendu or amendment. This command
        precedes any text of the paragraph. The version number of the change is
	<version>. [This is "1" for technical corrigenum 1; "2" for amendment 1].
	Kind is either "Revised" (an ordinary change), "Added" (for a paragraph
	added by the change), "AddedNormal" (for a paragraph added by the
	change which gets a normal paragraph number - used for insertions at
	the end of clauses and added to new clauses), "Deleted" (for a
	paragraph deleted by the change), "DeletedAdded" (for an
        added paragraph which is later deleted), "DeletedNoDelMsg" (for a
	paragraph deleted by the change; the "This paragraph was deleted"
        message is suppressed), "DeletedAddedNoDelMsg" (combines the last
	two kinds), or "RevisedAdded" (for an
        added paragraph which is later revised). [These control the paragraph
	numbering of the following paragraph.] The <DR_Number>(s) and/or
	<AI_Number>(s) that triggered the change are given. As many references
	as necessary can be given. (Zero is allowed). The format of the AI
	numbers is as described for @AILink.
	Note: If there are changes to the same paragraph in multiple versions,
	each version should have their own chgref.
	The ChgRefs should be in the order of the versions (first version 1,
	then version 2, etc.) The Kind should be consistent for all chgrefs -
	the numbering is the same no matter when the paragraph was added or
	deleted. That means "RevisedAdded" after "Added", etc.
@chgnote{<text>} Notes on particular change. This is treated as a comment; it
	has a separate command solely so that stripped easily in the future.
@chg{[Version=[<Version>],]New=[<new text>],Old=[<old text>]}
	Marks a particular change. The new text and the old text are given.
	(We have both sets of text so we can generate useful differences).
	@chg commands can be nested; it recommended that they be nested with
        the newest changes inside of older changes. The text may not contain
        any command that ends the paragraph. The Version is assumed to be '1'
        if that parameter is not given. Version is interpreted as for ChgRef.
@ChgAdded{Version=[<Version>],[NoPrefix=[T|F],][NoParamnum=[T|F],]
        [Type=[Leading|Trailing|Normal],][Keepnext=[T|F],]Text=[text]}
	Marks an insertion of a complete paragraph consisting of 'text'. This
	cannot be nested in other commands. The AARM prefix (if any) also is
	marked as an insertion. The optional parameters (conditionally) set the
	paragraph properties; NoPrefix, Noparanum, and KeepNext work the same
	as the @NoPrefix, @NoParanum, and @KeepNext commands if set to T,
	except that they're conditional on the paragraph text being inserted.
	Similarly, Type works the same as @Leading and @Trailing if set to
	those values, except that they are conditional. If omitted, NoPrefix
	is set to F, NoParanum is set to F, KeepNext is set to F, and
	Type is set to Normal.
@ChgDeleted{Version=[<Version>],[NoPrefix=[T|F],][NoParamnum=[T|F],]
        [Type=[Leading|Trailing|Normal],][Keepnext=[T|F],]Text=[text]}
	Marks a deletion of a complete paragraph consisting of 'text'. This
	cannot be nested in other commands. The AARM prefix (if any) also is
	marked as a deletion. The optional parameters (conditionally) set the
	paragraph properties; they work as described in ChgAdded. Note that
	they're conditional on the paragraph text being included in the
	document (even if it is marked as deleted).

@ChgImplDef{Version=[<version>],Kind=(<kind>),
        [InitialVersion=[<version>],]Text=<text>}
	Marks a changed implementation-defined entry. (Essentially a
	combination of ChgRef and Impldef.) <text> is the
	implementation-defined entry. See ChgRef and Impldef for details
	on the handling of the arguments. The optional InitialVersion parameter
	specifies the version number for the originally inserted text; if
	not specified, the Version number is used. (This is appropriate for
	added items, others should explicitly give an initial version.)

@ChgImplAdvice{Version=[<version>],Kind=(<kind>),
        [InitialVersion=[<version>],]Text=<text>}
	Marks a new or changed implementation advice entry. All IA entries
	are new with version 2. The clause and paragraph references (along
	with <text>) are saved to create part of Annex M. For the AARM,
	<text> is an annotation; otherwise, it is discarded.
	See ChgRef for details on the handling of Version and Kind arguments.
        The optional InitialVersion parameter specifies the version number for
	the originally inserted text; if not specified, the Version number is
	used.
@AddedImplAdviceList{Version=[2]}
	Generates the implementation advice list; it is inserted with the
	given version number.

@ChgDocReq{Version=[<version>],Kind=(<kind>),
        [InitialVersion=[<version>],]Text=<text>}
	Marks a new or changed documentation requirements entry. All DocReq
	entries are new with version 2. The clause and paragraph references
	(along with <text>) are saved to create part of Annex M. For the AARM,
	<text> is an annotation; otherwise, it is discarded.
	See ChgRef for details on the handling of Version and Kind arguments.
        The optional InitialVersion parameter specifies the version number for
	the originally inserted text; if not specified, the Version number is
	used.
@AddedDocReqList{Version=[2]}
	Generates the documentation requirements list; it is inserted with the
	given version number.

@ChgAspectDesc{Version=[<version>],Kind=(<kind>),Aspect=[<name>],
        [InitialVersion=[<version>],]Text=<text>}
	Marks a new or changed aspect description entry. All aspect
        descriptions are new with version 3. The clause and paragraph
        references (along with <name> and <text>) are saved to create part of
	Annex K. For the AARM, <text> is an annotation; otherwise, it is
	discarded. See ChgRef for details on the handling of Version and Kind
	arguments. The optional InitialVersion parameter specifies the version
	number for the originally inserted text; if not specified, the Version
	number is used.
@AddedDocReqList{Version=[3]}
	Generates the aspect description list; it is inserted with the
	given version number.


@ChgAttribute{Version=[<version>],Kind=(<kind>),ChginAnnex=[T|F],
	Leading=[T|F],Prefix=<Prefix>,AttrName=<Name>,
	{[Ref={<DR_Number>}|ARef={<AI_Number>}],}
        [InitialVersion=[<version>],][OmitAnnex=[<Omit>],]Text=<Text>}
	Marks a changed attribute entry. (Essentially a combination of
	ChgRef and Attribute.) ChginAnnex controls whether the change
	is reflected in the Annex. (Set this to F when the change is in
	text "glued" onto the annex paragraph.) Leading controls whether the
	first paragraph is leading or not. The optional InitialVersion parameter
        specifies the version number for the originally inserted text; if not
        specified, the Version number is used. The optional OmitAnnex boolean
	parameter means to omit the attribute from the annex (use this for
	moves of attributes, omit the deleted original definition). See ChgRef
	and Attribute for the meaning of the other parameters.
@ChgPrefixType{Version=[<version>],Kind=(<kind>),Text=[<text>]}
	Marks a changed prefix type text. Also, saves the indicated text to
	use as part of any following attribute definitions. The text is also
	written to the output. See ChgRef and PrefixType for more information.
@AddedSubheading{Version=[<version>],<text>}
	Same as Subheading, except that this heading is present only in
	new versions of the document.
@ChgToGlossary{Version=[<version>],Kind=(<kind>),Term=[<term>],Text=[<text>]}
	Marks a changed glossary entry. (Essentially a
	combination of ChgRef and ToGlossary.) <term> and <text> are the
	glossary entry; they can contain @Chg commands. See ChgRef and
        ToGlossary for details on the handling of the arguments.
@ChgToGlossaryAlso{Version=[<version>],Kind=(<kind>),Term=[<term>],Text=[<text>]}
	Marks a changed glossary entry. (Essentially a
	combination of ChgRef and ToGlossaryAlso.) <term> and <text> are the
	glossary entry; they can contain @Chg commands. See ChgRef and
        ToGlossaryAlso for details on the handling of the arguments.

-- Tabs:
@tabclear() - Clears all tab settings. Tabs are also cleared by leaving the
	@begin region that contains the tabstop command. Also ends any
	paragraphs.
@tabset(<list>) - Sets tab stops at the indicated values, in picas. The list
	is increasing (each value is larger than the one to its right), and
	separated by commas. Each value can be preceeded by a modifier:
	    L - fixed left tab;
	    P - proporational left tab.
	(Other modifiers are possible, but are hard to implement in text mode.)
	Proportional tab values are based on the font size; the values
	given are for 12 point fonts (in picas); the value is then adjusted
	for the actual (default) font size of the paragraph.
	Tab stops can only be set in formats that preserve
	breaks (i.e. Display). Also ends any paragraphs.
@\      - Move to the next tab stop.

-- Paragraphs:
@begin{<kind>}
	Marks the beginning of a group of paragraphs of a particular kind.
	See the definition of the kinds below. Most groupings have a
	subheading.
@end{<kind>}
	Marks the ending of a group of paragraphs of a particular kind.


-- Paragraph kinds (nesting is allowed; characteristics are not preserved
--		    unless specifically marked below):


    Pure formatting:
	Comment - The text is never output into the document.
	WideAbove- The paragraph has wider than usual space above, but is
		  otherwise normal.
	DescribeCode -
		  The text is indented 2 units.
	Example - The text is formatted in the example font (which is selected
		  in the master file) with an indent of 1 unit; spaces and
		  breaks are preserved. This format preserves size
		  characteristics of its parent (if any), except that if the
		  parent is "DescribeCode", the normal characteristics are
		  used. No page breaks are allowed within a paragraph.
		  Do not confuse this with "Examples", which is a text
		  grouping.
	ChildExample - The text is formatted in the example font (which is
		  selected in the master file); spaces and breaks are
		  preserved. This format preserves size and
		  indenting characteristics of its parent (if any);
		  with the exception that the text here is indented one
		  additional unit.
	Itemize - The text is indented and bulleted (with solid circle bullets).
		  The text preserves the size and indenting of its parent (if
		  any).
	InnerItemize - The text is indented to fit inside an Itemize or
		  Enumerate paragraph, and bulleted (with [smaller] solid
		  circle bullets).
	InnerInnerItemize - The text is indented to fit inside an InnerItemize
		  paragraph, and bulleted (with [smaller] solid circle bullets).
	Enumerate - The text is indented and numbered (that is, each paragraph
		  has a prefix number). The text preserves the size and
		  indenting of its parent (if any). The format of the number
		  depends on the ListFormat master setting: for RM,
		  a number followed by a period is used ["1."], for
		  ISO2004 a letter followed by a paren is used for the main
		  list ["a)"]; nested lists use a number ["1)"].
	InnerEnumerate - The text is indented to fit inside an Itemize or
		  Enumerate paragraph, and numbered as for Enumerate.
		  (These should only be used inside of regular Enumerate
		  blocks if ISO 2004 formatting is desired.)
	Display - A normal paragraph indented one level from its parent, except
		  that spaces and breaks are preserved. The text preserves the
		  size of its parent (if any). No page breaks are allowed
		  within a paragraph.
	Indent  - A normal paragraph indented one level from its parent.
		  The text preserves the size of its parent (if any).
	SyntaxDisplay - The text is in a smaller font, is indented one level,
		  and spaces and breaks are preserved. No page breaks are
		  allowed within a paragraph.
	Description - A paragraph with text indented 3 units; but the item
		  is a hanging undent to the normal paragraph level. Usually
		  used for attributes, but sometimes used for other items.
		  Same as Hang3List.
	DescExample - The text is formatted in a fixed-width example font with
		  an indent of 4 units; spaces and breaks are preserved. No page breaks
		  are allowed within a paragraph.
	SyntaxText -
		  The text is indented 1 unit. This is intended to match the
		  indentation of syntax and is usually used in the syntax
		  grouping; however syntax is usually in the swiss font.
	Hang1List -
  		  A paragraph with text indented 1 unit; but the item
		  is a hanging undent to the normal paragraph level.
	Hang2List -
  		  A paragraph with text indented 2 units; but the item
		  is a hanging undent to the normal paragraph level.
	Hang3List -
  		  A paragraph with text indented 3 units; but the item
		  is a hanging undent to the normal paragraph level.
	Hang4List -
  		  A paragraph with text indented 4 units; but the item
		  is a hanging undent to the normal paragraph level.
	Small -	  The text has the size of an AARM note, but doesn't
		  have any headers or extra indentation.
	Title -   The text is 5 size units (usually 5 points) larger than
		  normal.
	Bundle -  The text in the 'bundle' should never be page-breaked.
		  The format is unchanged.
	TwoCol -  Sets the text to a two-column format. The text format
		  is unchanged.
	FourCol - Sets the text to a four-column format. The text format
		  is unchanged.

    RM groupings:
	Intro	  - Introductory text. No heading.
	Syntax	  - Syntax.
	Resolution- Name resolution rules.
	Legality  - Legality rules.
	StaticSem - Static Semantics.
	LinkTime  - Post-Compilation Rules.
	RunTime   - Dynamic Semantics.
	Bounded   - Bounded (Run-Time) errors.
	Erron	  - Erroneous Execution.
	ImplReq	  - Implementation Requirements.
	DocReq	  - Documentation Requirements.
	Metrics	  - Metrics.
	ImplPerm  - Implementation Permissions.
	ImplAdvice- Implementation Advice.
	Notes	  - Notes. (Each of these is numbered and indented 1 unit.
		    The format is controlled by the @NoteFormat command
		    in the master file.)
	SingleNote - A single note (it is indented 1 unit, but not numbered.
		    The format is controlled by the @NoteFormat command
		    in the master file.)
	Examples  - Examples. (Do not confuse this with the text format
		    "Example". This is a grouping with a subhead. It is in
		    the normal font by default; often an "Example" is found
		    inside of "Examples".)
	NotIso    - Text that is not included in ISO documents. No format is implied.
	IsoOnly   - Text that is included only in ISO documents. No format is implied.
	RMOnly    - Text that is not included in the AARM (that is, it is only
		    included in the output if HideAnnotations is used). No
		    format is implied.

    AARM-only groupings: (not shown if HideAnnotations is used)
	MetaRules - Language Design Principles.
	Inconsistent83 - Inconsistencies with Ada 83.
	Incompatible83 - Incompatibilities with Ada 83.
	Extend83  - Extensions to Ada 83.
	DiffWord83- Wording Changes from Ada 83.
	Inconsistent95 - Inconsistencies with Ada 95.
	Incompatible95 - Incompatibilities with Ada 95.
	Extend95  - Extensions to Ada 95.
	DiffWord95- Wording Changes from Ada 95.
	Inconsistent2005 - Inconsistencies with Ada 2005.
	Incompatible2005 - Incompatibilities with Ada 2005.
	Extend2005  - Extensions to Ada 2005.
	DiffWord2005- Wording Changes from Ada 2005.
	Inconsistent2012 - Inconsistencies with Ada 2012.
	Incompatible2012 - Incompatibilities with Ada 2012.
	Extend2012  - Extensions to Ada 2012.
	DiffWord2012- Wording Changes from Ada 2012.
	AARMOnly  - Text that is not included in the RM. No format is implied.

    AARM annotations: (not shown if HideAnnotations is used)
	Reason    - Why a rule is necessary.
	Ramification- Consequences of rules. (Important ones should be Notes).
	Discussion - General annotations.
	TheProof  - Informal proof as to why Notes or Redundant text follows
		    from the language.
	ImplNote  - A note on implementation.
	Honest    - To be Honest: Only pedants need apply.
	GlossaryMarker - Looks like a glossary entry in the AARM (but isn't
		    really one). (Also internally used by the formatter for
		    real glossary entries.)
	ElementRef - (For ASIS) Marks an Element Reference.
	ChildRef  - (For ASIS) Marks child references for the preceding
		    Element Reference.
	UsageNote - (For ASIS) Marks a Usage Note.

-- Text Macros:

<Grouping>Name  - The name of a kind of rule (as in "This is a
		  @ResolutionName.").
<Grouping>Title - The title of a kind of rule (as in "This belongs under
		  "@ResolutionTitle".").
	where <Grouping> is any of the paragraph grouping kinds listed above.

@intlstdname  - Generates "International Standard" when ShowISO is the state, and
                "document" when HideISO is the state.
@intlstdtitle - Generates "International Standard" when ShowISO is the state, and
                "Reference Manual" when HideISO is the state.
@stdtitle     - Generates "Standard" when ShowISO is the state, and
                "Reference Manual" when HideISO is the state.

-- Character Macros:

These represent characters not available in the lower 128 of Latin-1, including
various mathematical symbols.

@em	- EM dash (a very long dash)
@en	- EN dash (a long dash)
@thin   - A thin space (quarter em if possible)
@geq	- Greater than or equal symbol
@gt	- Greater than symbol
@leq	- Less than or equal symbol
@lt	- Less than symbol
@neq	- Not equal symbol
@pi	- Pi
@smldotlessi -- Small Dotless I (for examples). Use @Unicode(305) if we ever implement that.
@capdottedi -- Capital Dotted I (for examples). Use @Unicode(304) if we ever implement that.
@singlequote - Single quote ('''). Used to avoid confusion in syntax rules.
@latin1{<number>} - Generate the Latin-1 character with the decimal code
	"number".
@unicode{<number>} - Generate the Unicode character with the decimal code
	"number". Careful: this is unchecked; usually, the characters used
	should be limited to the 615 generally supported by Windows.
@times  - The middle dot multiply symbol.
@porm   - The plus or minus symbol.
@ceiling{<text>} - The ceiling operator, surrounding <text>.
@floor{<text>} - The floor operator, surrounding <text>.
@abs{<text>} - The mathematical absolute value operation, surrounding <text>.
@log{<text>} - The log operation, surrounding <text>. (In practice, this is
	 always translated "log(<text>)").
@lquote - Left (directed) single quote.
@rquote - Right (directed) single quote.
@ldquote - Left (directed) double quote.
@rdquote - Right (directed) double quote.
@lquotes - Pair of left (directed) single quotes. (Note: The ARG has directed
	   that these be changed to a left double quote, so this is now the
	   same as ldquote.)
@rquotes - Pair of right (directed) single quotes. (Note: The ARG has directed
	   that these be changed to a right double quote, so this is now the
	   same as rdquote.)

-- Tables:
@table(Columns=<number>,
       Alignment=<AllLeft|AllCenter|CenterExceptFirst>,
       FirstColWidth=<number>,
       LastColWidth=<number>,
       NoBreak=<T|F>,
       Border=<T|F>,
       SmallSize=<T|F>,
       Caption=<text>,
       Headers=<text>,
       Body=<row_text>)

       Defines a table.
	- Columns must be a single digit (2-9).
	- Alignment defines the column text alignment (centered or left edge).
	- FirstColWidth defines the width of the first column compared to
	  the rest - it's in multiples of the standard column width.
          Note that some target formats with self-sizing columns (i.e. HTML)
          ignore this value. It must be a single digit from 1 to 9.
	- LastColWidth defines the width of the last column compared to
	  the rest - it's in multiples of the standard column width.
          Note that some target formats with self-sizing columns (i.e. HTML)
          ignore this value. It must be a single digit from 1 to 9.
	- If NoBreak is T, the table will be formatted on a single page.
	  Otherwise, it will be allowed to be split across pages. This
	  must be F if the table is larger than a single page!
	- If Border is T, then a border will be drawn around the table;
          otherwise, not border will be used.
	- If SmallSize is T, then the text size will be small (AARM-sized);
	  else the text size will be normal.
	- Caption defines the table caption. This spans the entire table.
	- Headers defines the table headers. Each header is separated by
	  a tab stop (@\). This should be a single line.
	- Body defines the table body. Each row should be a single line,
	  with each item separated by a tab stop.
	  The text may contain character and text formatting commands, but
	  no paragraph commands. But no text command may extend across the
	  tab marking the end of an item.
@Last	- Marks the end of the second last row of the table. (If left out,
	  the bottom line of the table may be missing).

-- Pictures: (Graphics, Images)

@PictureInline(Alignment=<Inline|FloatLeft|FloatRight>,
         Border=<None|Thin|Thick>,
         Height=<nnn>,
         Width=<nnn>,
         Name=<name>,
         Descr=<descr>)
@PictureAlone(Alignment=<Left|Right|Center>,
         Border=<None|Thin|Thick>,
         Height=<nnn>,
         Width=<nnn>,
         Name=<name>,
         Descr=<descr>)
	Includes a picture in the output. PictureAlone is a stand-alone
	picture with the appropriate alignment; it must appear outside
	of a paragraph. PictureInline occurs in the flow of text (Inline),
	or floats to the appropriate margin; it must appear inside of a
	paragraph. Otherwise, these are the same.
	The picture file's simple name is
	"name"; the file is assumed to be a .PNG or .JPG, found in the output
	directory. (It needs to be included with the HTML output.)
	"descr" is a description of the picture; it's used for the popups
	in HTML. Height and Width are the picture size in pixels.
	Border specifies the border of the picture.
	[Note: Inline alignment is not recommended; the picture location
	cannot be controlled, especially on RTF, it can appear in margins
	and other bad locations.]

-------------------

Use to create Ada standard documents.


The master file AARM.MSM specifies the Annotated Ada Reference Manual. This
is mainly intended for implementors and language lawyers. It includes
annotations. (In the past, it also included visible index entries, but that
has been turned off by popular demand).

The master file RM.MSM specifies the Ada Reference Manual. This is the
version used by most users.

The master file ISO-RM.MSM specifies Ada Reference Manual in ISO format.
This version lacks some sections, paragraph numbers, and is formatted for A4
paper.

Versions:
   0-Original Ada 95 (equivalent to No-Changes)
   1-Technical Corrigendum 1 for Ada 95
   2-Amendment 1 [Ada 2005 (standard published 2007, so could be considered Ada 2007)]
   3-3rd Edition (Ada 2012)
   4-Technical Corrigendum 1 for Ada 2012
   5-4th Edition (Ada 202x) - Not official yet.

Please note that there some changes to earlier versions (mostly typographical,
but there are some that are significant) that are not preserved in the Ada 2012
source code (.MSM and .MSS files), so to get an exact match to one of the
previous versions, you must use the source code appropriate for that version.

One specific change; the MSM files for Ada 2012 have @SubdivisionNames{Clause}
(as this is required by ITTF) while the MSM files for Ada 95 and Ada 2005 have
@SubdivisionNames{Section} (as this was required when those standards were
current).

In addition, several clauses were moved to different numbers within the
Standard (for both Ada 2012 and Ada 2005); usually, these were done by
by just renaming the clause (and changing the @Label command) and the
original location is not preserved.

